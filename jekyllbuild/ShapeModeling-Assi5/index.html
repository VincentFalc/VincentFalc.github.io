<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
<title>Vincent F. - Shape Modeling Forces simulation </title>

<meta content='width=device-width, initial-scale=1, maximum-scale=1' name='viewport'/>
<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:500,600' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="/css/main.css">
<link rel="stylesheet" id="color-change" href="">
<link rel="stylesheet" id="switch-style" href="/css/grid.css">
<link rel="alternate" type="application/rss+xml" title="Vincent F." href="http:/localhost:4000/feed.xml">

    </head>

    <body>
        <header class="head">
            <div class="row">
    <a href="/" class="logo noline">
        <!-- full logo version with slogan, icon and text, add the class .ts-full if you want to work with some of the existing CSS -->
   <svg version="1.1" viewBox="0 0 850.61096 179.54858" class="ts-full">
    <g transform="translate(-49.00717,-350.11674)">
        <g transform="matrix(0.65068572,0,0,0.65068572,11.104727,118.00494)" class="icon">
            <path d="m 101.39622,391.43518 191.99569,0 c 5.04555,0 9.10749,46.87698 9.10749,105.10533 0,58.22836 -4.06194,105.10533 -9.10749,105.10533 l -191.99569,0 c -5.045545,0 -9.107486,-46.87697 -9.107486,-105.10533 0,-58.22835 4.061941,-105.10533 9.107486,-105.10533 z" class="rectangle" />
            <path d="m 165.8125,358.21875 -5.1875,99.21875 -100.875,0 0,7.625 100.46875,0 -3.28125,62.59375 -97.1875,0 0,7.59375 96.78125,0 -5,95.5 7.625,0.40625 5.03125,-95.90625 62.5625,0 -5,95.5 7.59375,0.40625 5.03125,-95.90625 98.28125,0 0,-7.59375 -97.875,0 3.28125,-62.59375 94.59375,0 0,-7.625 -94.1875,0 5.15625,-98.84375 -7.59375,-0.375 -5.1875,99.21875 -62.5625,0 5.15625,-98.84375 -7.625,-0.375 z m 2.0625,106.84375 62.5625,0 -3.28125,62.59375 -62.5625,0 3.28125,-62.59375 z" class="lines" />
        </g>
        <text x="235.15662" y="477.12143" class="gridster">
            <tspan x="235.15662" y="477.12143">VFProjects</tspan>
        </text>
        <text x="304.80173" y="512.31683" class="slogan">
            <tspan x="304.80173" y="512.31683">Personal and professional work</tspan>
        </text>
    </g>
</svg>
        <!-- logo version without slogan, add the class .ts-no-slogan if you want to work with some of the existing CSS -->
<svg version="1.1" viewBox="0 0 677.61096 179.54858" class="ts-no-slogan">
    <g transform="translate(-49.00717,-350.11674)">
        <g transform="matrix(0.65068572,0,0,0.65068572,11.104727,118.00494)" class="icon">
            <path d="m 101.39622,391.43518 191.99569,0 c 5.04555,0 9.10749,46.87698 9.10749,105.10533 0,58.22836 -4.06194,105.10533 -9.10749,105.10533 l -191.99569,0 c -5.045545,0 -9.107486,-46.87697 -9.107486,-105.10533 0,-58.22835 4.061941,-105.10533 9.107486,-105.10533 z" class="rectangle" />
            <path d="m 165.8125,358.21875 -5.1875,99.21875 -100.875,0 0,7.625 100.46875,0 -3.28125,62.59375 -97.1875,0 0,7.59375 96.78125,0 -5,95.5 7.625,0.40625 5.03125,-95.90625 62.5625,0 -5,95.5 7.59375,0.40625 5.03125,-95.90625 98.28125,0 0,-7.59375 -97.875,0 3.28125,-62.59375 94.59375,0 0,-7.625 -94.1875,0 5.15625,-98.84375 -7.59375,-0.375 -5.1875,99.21875 -62.5625,0 5.15625,-98.84375 -7.625,-0.375 z m 2.0625,106.84375 62.5625,0 -3.28125,62.59375 -62.5625,0 3.28125,-62.59375 z" class="lines" />
        </g>
        <text x="235.15662" y="477.12143" class="gridster">
            <tspan x="235.15662" y="477.12143">Projects</tspan>
        </text>
    </g>
</svg>
        <!-- icon logo version, add the class .ts-icon if you want to work with some of the existing CSS -->
<svg version="1.1" viewBox="0 0 179.52826 179.54858" class="ts-icon">
    <g transform="translate(-49.00717,-350.11674)">
        <g transform="matrix(0.65068572,0,0,0.65068572,11.104727,118.00494)" class="icon">
            <path d="m 101.39622,391.43518 191.99569,0 c 5.04555,0 9.10749,46.87698 9.10749,105.10533 0,58.22836 -4.06194,105.10533 -9.10749,105.10533 l -191.99569,0 c -5.045545,0 -9.107486,-46.87697 -9.107486,-105.10533 0,-58.22835 4.061941,-105.10533 9.107486,-105.10533 z" class="rectangle" />
            <path d="m 165.8125,358.21875 -5.1875,99.21875 -100.875,0 0,7.625 100.46875,0 -3.28125,62.59375 -97.1875,0 0,7.59375 96.78125,0 -5,95.5 7.625,0.40625 5.03125,-95.90625 62.5625,0 -5,95.5 7.59375,0.40625 5.03125,-95.90625 98.28125,0 0,-7.59375 -97.875,0 3.28125,-62.59375 94.59375,0 0,-7.625 -94.1875,0 5.15625,-98.84375 -7.59375,-0.375 -5.1875,99.21875 -62.5625,0 5.15625,-98.84375 -7.625,-0.375 z m 2.0625,106.84375 62.5625,0 -3.28125,62.59375 -62.5625,0 3.28125,-62.59375 z" class="lines" />
        </g>
    </g>
</svg>
    </a>
</div>

            <!-- menu, we did go with a static one, you can build a dynamic one, just google a little around -->
<div class="main-menu">
    <div class="content">
        <nav id="menu">
            <a class="toggle-link noline"><i class="fa fa-close fa-lg"></i></a>
            <ul>
                <li>
                    <a class="homelink" href="/">Home</a>
                </li>
                <li>
                    <a href="/archive">Archive</a>
                </li>
                <!--
                <li>
                    <a href="/typography">Typography</a>
                </li>
                <li><a class="dropdown-button" href="#" data-activates='drop-example'>Page Layouts&nbsp;&nbsp;<i class="fa fa-caret-down"></i></a>
                </li>
                <div id="drop-example" class="dropdown-content">
                    <li>
                        <a href="/page-full">page-full</a>
                    </li>
                    <li>
                        <a href="/page-classic-sidebar-right">page classic sidebar right</a>
                    </li>
                    <li>
                        <a href="/page-classic-sidebar-left">page classic sidebar left</a>
                    </li>
                    <li>
                        <a href="/page-material-sidebar-right">page material sidebar right</a>
                    </li>
                    <li>
                        <a href="/page-material-sidebar-left">page material sidebar left</a>
                    </li>
                </div>
                <li>
                    <a href="#colorswitch" class="modal-trigger">Change Colors <i class="fa fa-cog"></i></a>
                </li>
                -->
            </ul>
        </nav>
        <nav class="iconnav">
            <ul>
                <li class="sicon">
                    <a href='#search'><i class='fa fa-search'></i></a>
                </li>
                <!--
                
                <li class="social">
                    <a href="" class="tumblr"><i class="fa fa-tumblr"></i></a>
                </li>
                 
                <li class="social">
                    <a href="" class="pinterest"><i class="fa fa-pinterest"></i></a>
                </li>
                 
                <li class="social">
                    <a href="" class="instagram"><i class="fa fa-instagram"></i></a>
                </li>
                 
                <li class="social">
                    <a href="" class="twitter"><i class="fa fa-twitter"></i></a>
                </li>
                 
                <li class="social">
                    <a href="" class="facebook"><i class="fa fa-facebook"></i></a>
                </li>
                 
                <li class="social">
                    <a href="" class="youtube"><i class="fa fa-youtube"></i></a>
                </li>
                 
                <li class="social">
                    <a href="" class="vimeo"><i class="fa fa-vimeo-square"></i></a>
                </li>
                 
                <li class="social">
                    <a href="" class="soundcloud"><i class="fa fa-soundcloud"></i></a>
                </li>
                
                -->
            </ul>
        </nav>
        <a href='#menu' class="toggle-link noline">
            <i class="fa fa-navicon"></i>
        </a>
    </div>
</div>




<div id="colorswitch" class="modal color-change">
    <div class="modal-content">
      <h4>Change Color Palette</h4>
      <p>
      <img id="indigo" alt="color palette preview indigo" src="/media/compressed/indigo.jpg">
      <img id="brown" alt="color palette preview brown" src="/media/compressed/brown.jpg">
      <img id="green" alt="color palette preview green" src="/media/compressed/green.jpg">
      <img id="teal" alt="color palette preview teal" src="/media/compressed/teal.jpg">
      </p>
    </div>
    <div class="modal-footer">
      <a href="#!" class="modal-action modal-close waves-effect waves-green btn-flat">close</a>
    </div>
  </div>
        </header>
        <div id="search">
    <form role="search" id="searchform">
        <input type="search" placeholder="Search"/>
    </form>
</div>

        <div class="margin">
            <div class="content full">
                <div class="content-container">
                    <article>
                        
                            
                                <img class="featimg" src="/media/compressed/GradientDescent.gif" alt="GradientDescent.gif">
                            
                        

                        <h1 class="post-title">
                            Shape Modeling Forces simulation
                        </h1>
                        <div class="meta">
                            

    <span class="author">Posted by
        
        
            <a href="/author/VF">
                
                    Vincent F.
                
            </a>
        
    </span>

 &bull;
                            <span class="date">
                                Published on May 07, 2018
                            </span>
                        </div>
                        
                        <div class="post-content">
                            <h5 id="tldr">TL;DR</h5>
<p>This project was linked to a lecture about Shape Modeling. This project presents a method to obtain the stable position of a mesh constrained under forces. The simulation is mainly based on Springs.
<br />
The main idea is to compare the mesh with a Spring’s network. Then, the problem is to minimize the global stress (which’s the sum of the individual Spring stress) of the mesh, by an optimization method. Here again we are talking about reducing the energy of the mesh.
<br />
We have choices on the Spring modelisation and the optimization method. We will go through first order optimization (Gradient descent) and second order optimization (Newton’s method).
<br /></p>

<h5 id="table-of-contents">Table of Contents</h5>
<p><a href="#Mass">1. Mass-spring simulation</a>  <br />
<a href="#Gradient">1.1. Gradient Descent and Line Search</a>  <br />
<a href="#simulation">1.2. Spring simulation with gradient descent</a>  <br />
<a href="#Newton">1.3. Newton’s method</a>  <br />
<a href="#method">1.4. Spring simulation with Newton’s method</a>  <br />
<a href="#FEM">2. FEM Simulation</a>  <br />
<a href="#Graddescent">2.1. FEM simulation with gradient descent</a>  <br />
<a href="#Newdescent">2.2. FEM simulation with Newton’s method</a>  <br /></p>

<p><a name="Mass"></a></p>

<h4 id="1-mass-spring-simulation">1. Mass-spring simulation</h4>

<p><a name="Gradient"></a></p>

<h4 id="11-gradient-descent-and-line-search">1.1. Gradient Descent and Line Search</h4>

<p>We can validate our gradient descent method on small and easy to debug problem.
So for this first part, we’re going to validate the method on the Rosenbrock function
<a href="https://en.wikipedia.org/wiki/Rosenbrock_function">-&gt; Function</a>
<br />
We will write several function :</p>
<ul>
  <li>computeValue(const VectorXd&amp; x) will return f(x), with f the Rosenbrock function</li>
  <li>addGradientTo(VectorXd&amp; grad, const VectorXd&amp; x) will add to the gradient vector (first paramter) the computed gradient of the Rosenbrock function (analytical)</li>
  <li>doLineSearch will performs a line search of a better (lower value) solution, in a particular direction (given by dx) of research
<br />
    <h6 id="explanation">Explanation</h6>
    <p>We do compute the value as a simple function evaluation.</p>
  </li>
</ul>

<p>We do calculate the gradient of the function anaticaly and then compute it at one specific point. We get the two directional derivative of this function at that point.</p>

<p align="center">
  <img style="height : 200px;" src="/media/compressed/Gradient.png" />
</p>

<p>We do compute the search direction as the opposite of the gradient.
We do a line search as the current position, added of a ‘dx’ in the search direction, that we halves if the evaluation of the function at this position is higher than the current point - meaning that it makes no sense to “jump” there.
So, regarding the first value of Dx, we will consider 1<em>Dx,0.5</em>Dx,0.25<em>Dx, 0.125</em>Dx … until we get a “better” value of the total Energy.</p>

<h6 id="usage">Usage</h6>
<pre><code class="language-C++">    virtual double computeValue(const VectorXd&amp; x) {
		// Ex 1.1
		double xV = x[0];
		double yV = x[1];
		return (a-xV) * (a-xV) + b * (yV-(xV*xV))*(yV-(xV*xV));
	}

    (...)

    virtual void addGradientTo(VectorXd&amp; grad, const VectorXd&amp; x) {

		// Ex 1.1
		double xV = x[0];
		double yV = x[1];

		//Calculate the directionnal derivatives
		double dfdx = 2 * (-a + xV + 2 * b * xV * (xV*xV - yV));
		double dfdy = 2 * b * (yV - xV*xV);

		//Store it
		grad[0] += dfdx; //+ grad[0];
		grad[1] += dfdy; //+ grad[1]; /// ? Adds ? Or replace ? Or appends ?
    }

    (...)

    virtual void computeSearchDirection(ObjectiveFunction *function, const VectorXd &amp;x, VectorXd &amp;dx)
	{
		// Ex. 1.1
		VectorXd grad;
		grad.resize(x.rows(), 1);
		function-&gt;addGradientTo(grad, x);

		//Store it
		dx[0] = -grad[0];
		dx[1] = -grad[1];
		// Note : no normalization, otherwise we loose information ?
	}

    (...)

	virtual void doLineSearch(ObjectiveFunction *function, const VectorXd &amp;dx, VectorXd &amp;xi)
	{

		// Ex. 1.1
        (...)

		for (int i = 0; i &lt; maxLineSearchIterations &amp;&amp; !isInferior; i++)
		{

			if (function-&gt;computeValue(tmpx) &gt; actualValue)
			{ //We have " a higher point "
				tmpx = xi + dx*currentAlpha;
				currentAlpha *= beta;
			}
			else
			{ // We have a lower point, we stop here
				isInferior = true; //Not really necessary ...
				break;
			}
		}

		//Storage
		xi = tmpx;
	}
    (...)

</code></pre>

<h6 id="result">Result</h6>

<p>The minimum of the Rosenbrock functin is (1,1) and we see the gradient descent find this value, but with a high number of iterations.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Gradient descent:
converged:  yes
iterations: 9750
min. x:     1.00001 1.00002
min. value: 6.17752e-11
</code></pre></div></div>

<hr />

<p><a name="simulation"></a></p>

<h4 id="12-spring-simulation-with-gradient-descent">1.2. Spring simulation with gradient descent</h4>

<p>Now that your basic function are functionnal, we can get to a harder problem : the spring simulation of the mesh.
<br /></p>

<p>Similarly, we will write several function :</p>
<ul>
  <li>getEnergy(const VectorXd&amp; x, const VectorXd&amp; X) will spring energy given the current list of state x and list of rest state X of every spring.</li>
  <li>addEnergyGradientTo(const VectorXd&amp; x, const VectorXd&amp; X, VectorXd&amp;
grad), which add to the gradient vector (last paramter) the computed gradient of the spring energy given states x and rest states X.</li>
  <li>doLineSearch will be the same as previously.
<br /></li>
</ul>

<h6 id="explanation-1">Explanation</h6>
<p>We calculate the energy of a Spring as the expression provided in the PDF.</p>

<p>We calculate the gradient of the energy as : f = -dE. So we calculate the opposite of the Force function, as provided in the PDF, at each point (2 ends) of the current Spring.
The calculated value is stored in the gradient Vector, at the place of each node (x and y components).</p>

<h6 id="usage-1">Usage</h6>
<pre><code class="language-C++">	virtual double getEnergy(const VectorXd&amp; x, const VectorXd&amp; X) {
		// Ex 1.2
		//Compute actual length
		Vector2d elong_Pos_0 = getNodePos(0, x);
		Vector2d elong_Pos_1 = getNodePos(1, x);
		double l = getLength(elong_Pos_0, elong_Pos_1);
	
		//Compute rest length
		Vector2d rest_Pos_0 = getNodePos(0, X);
		Vector2d rest_Pos_1 = getNodePos(1, X);
		double L = getLength(rest_Pos_0, rest_Pos_1);

		// Energy = 0.5 * k * ((l - L)/L)²
		return 0.5 * k * L * (l-L)/L * (l-L)/L;
	}

	virtual void addEnergyGradientTo(const VectorXd&amp; x, const VectorXd&amp; X, VectorXd&amp; grad) {
		// Ex 1.2
		// Task: Given `x` and `X`, add the gradient of the spring energy to `grad`.

		//We consider the gradient of E as : f = -dE
		// f = - k * ((l/L) - 1) * u
		//Compute rest length
		Vector2d rest_Pos_A = getNodePos(0, X); 
		Vector2d rest_Pos_B = getNodePos(1, X); 
		double L_norm = getLength(rest_Pos_A, rest_Pos_B);

		//Compute actual length
		Vector2d elong_Pos_A = getNodePos(0, x); 
		Vector2d elong_Pos_B = getNodePos(1, x);
		Vector2d l_vec = elong_Pos_A - elong_Pos_B;
		double l_norm = getLength(elong_Pos_A,elong_Pos_B);

		Vector2d u = l_vec.normalized();

		double cste = k * ((l_norm-L_norm)/L_norm);
		assert(std::isfinite(cste));

		grad[2*getNodeIndex(0)] += cste * u[0];
		grad[2*getNodeIndex(0)+1] += cste * u[1];
		grad[2*getNodeIndex(1)] += -cste * u[0];
		grad[2*getNodeIndex(1)+1] += -cste * u[1];

	}

</code></pre>

<h6 id="result-1">Result</h6>
<div style="text-align:center">
<p align="center">
<img style="height : 300px;" src="/media/compressed/GradientDescent.png" />
<img style="height : 300px;" src="/media/compressed/GradientDescent.gif" />
<br />
  Result of "Test" button - Gradient Descent - Spring - Default max stress (0.02)
</p>
</div>

<p>The gradient descent give a minimal value, with a high number of iteration, that we will be able to compare with output of other methods.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Gradient Descent
total energy = 117.884
# iterations = 3468
min def at   = 7.80134e-08
max def at   = 0.00641764
</code></pre></div></div>

<hr />
<p><a name="Newton"></a></p>

<h4 id="13-newtons-method">1.3. Newton’s method</h4>

<p>The first order can get to a solution, but need many iterations (especially in some particular situation, if the function is of degree 2 or more).
<br />
Therefore, we can compute a second order solution. As for the first order, we begin by the Rosenbrock Function.
<br />
We will write several function :</p>
<ul>
  <li>addHessianEntriesTo, which adds its second order derivatives as Eigen::Triplets.</li>
  <li>computeSearchDirection, which computes the search direction dx given an objective function. We use Eigen::SimplicialLDLT to solve the search Direction.</li>
</ul>

<h6 id="explanation-2">Explanation</h6>
<p>We calculate analytically the hessian, and we compute it directly.</p>

<p align="center">
  <img style="height : 500px;" src="/media/compressed/hessian.jpg" />
</p>

<p>We then solve the system to get the dx value.</p>

<h6 id="usage-2">Usage</h6>
<pre><code class="language-C++">virtual void addHessianEntriesTo(std::vector&lt;Tripletd&gt; &amp;hessianEntries, const VectorXd &amp;x)
	{
		// Ex 1.2
		// write d^2f/dx^2 in `hessianEntries`
		double xV = x[0];
		double yV = x[1];

		//Fill the Hessian
		hessianEntries.push_back(Tripletd(0, 0, -4 * b * (yV - xV * xV) + 8 * b * xV * xV + 2));
		hessianEntries.push_back(Tripletd(0, 1, -4 * b * xV));
		hessianEntries.push_back(Tripletd(1, 0, -4 * b * xV));
		hessianEntries.push_back(Tripletd(1, 1, 2 * b));
	}

    (...)

	virtual void computeSearchDirection(ObjectiveFunction *function, const VectorXd &amp;x, VectorXd &amp;dx)
	{
    (...)
		// Ex 1.3
		Eigen::SimplicialLDLT&lt;Eigen::SparseMatrix&lt;double&gt;&gt; solver;
    (...)

		function-&gt;addHessianEntriesTo(hessianEntries, x);
		hessianSparse.setFromTriplets(hessianEntries.begin(), hessianEntries.end());

		function-&gt;addGradientTo(grad, x);
		grad = -1 * grad;
		rightSide = grad.sparseView();

		solver.compute(hessianSparse);
		solved = solver.solve(rightSide);

		dx = MatrixXd(solved);
	}

    (...)

</code></pre>

<h6 id="result-2">Result</h6>

<p>We see, compared to the gradient descent, that Newton method give a correct result, but only in one iteration. 
Note : the 0.000001 of error for the gradient descent is due to the way the calculation is stopped. If we don’t see any improvement (0.00001 or more difference) between two iterations, we stop the process. As the process converge very slowly, there is not more improvement (numerically) and so the process is stopped.
Whereas for the Newton’s Method, in one jump, it goes right at the good position.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Newton's method:
converged:  yes
iterations: 4
min. x:     1 1
min. value: 2.91398e-13
</code></pre></div></div>

<hr />
<p><a name="method"></a></p>

<h4 id="14-spring-simulation-with-newtons-method">1.4. Spring simulation with Newton’s method</h4>

<p>Now that your basic function are functionnal for the second order method, we can get similarly improve it to the Spring simulation.
<br /></p>

<p>Similarly, we will write several function :</p>
<ul>
  <li>addHessianEntriesTo(const VectorXd&amp; x, const VectorXd&amp; X, VectorXd&amp;
grad), adds the second order derivatives of the spring energy to the Hessian (hesEntries)
<br /></li>
</ul>

<h6 id="explanation-3">Explanation</h6>
<p>We compute analytically the Hessian and implement it the same way. The disposition in the “global” hessian is dependent on which point we consider and which derivative of it we compute.</p>

<p>The manual computation is verified automatically :</p>
<p align="center">
  <img style="height : 700px;" src="/media/compressed/Hessian.png" />
</p>

<h6 id="usage-3">Usage</h6>
<pre><code class="language-C++">virtual void addHessianEntriesTo(std::vector&lt;Tripletd&gt; &amp;hessianEntries, const VectorXd &amp;x)
	{
		//Compute rest length
		Vector2d rest_Pos_A = getNodePos(0, X); 
		Vector2d rest_Pos_B = getNodePos(1, X); 
		Vector2d L_vec = rest_Pos_A - rest_Pos_B;
		double L_norm = getLength(rest_Pos_A, rest_Pos_B);

		//Compute actual length
		Vector2d elong_Pos_A = getNodePos(0, x); 
		Vector2d elong_Pos_B = getNodePos(1, x);
		Vector2d l_vec = elong_Pos_A - elong_Pos_B;
		double l_norm = getLength(elong_Pos_A,elong_Pos_B);

		Vector2d u = l_vec.normalized();

		double ga = k/(L_norm*L_norm*l_norm*l_norm); //k/(L²*l²)
		double be = -(k*((l_norm/L_norm)-1))/(L_norm*l_norm*l_norm*l_norm); //-k*((l/L)-1)/(L*l^3)
		double al = (k*((l_norm/L_norm)-1))/(L_norm*l_norm); //k* (l/L -1)/(L*l)

		double A = l_vec[0]*l_vec[0]*ga + l_vec[0]*l_vec[0]*be + al; 
		double B = l_vec[0]*l_vec[1]*ga + l_vec[0]*l_vec[1]*be; 
		//double C = ; 
		double D = l_vec[1]*l_vec[1]*ga + l_vec[1]*l_vec[1]*be + al; 

    (...)

		//Create hessian
		int nodeAIndex = 2*getNodeIndex(0);
		int nodeBIndex = 2*getNodeIndex(1);
		hesEntries.push_back(Tripletd(nodeAIndex, nodeAIndex, 			A )); 	// Haut gauche 	// Ligne haut, Exi, dxi
		hesEntries.push_back(Tripletd(nodeAIndex, nodeAIndex + 1,		B )); 	// Haut droite 	// Ligne haut, Exi, dyi
		hesEntries.push_back(Tripletd(nodeAIndex+1, nodeAIndex, 		B ));	// Bas gauche 	// Ligne bas, Exi, dxi
		hesEntries.push_back(Tripletd(nodeAIndex+1, nodeAIndex +1, 		D ));	// Bas droite 	// Ligne bas, Exi, dyi

		hesEntries.push_back(Tripletd(nodeAIndex, nodeBIndex, 			- A )); // Haut gauche 	// Ligne haut, Exi, dxj
		hesEntries.push_back(Tripletd(nodeAIndex, nodeBIndex + 1, 		-B )); 	// Haut droite 	// Ligne haut, Exi, dyj
		hesEntries.push_back(Tripletd(nodeAIndex+1, nodeBIndex,  		-B ));	// Bas gauche 	// Ligne bas, Exi, dxj
		hesEntries.push_back(Tripletd(nodeAIndex+1, nodeBIndex +1, 		- D ));	// Bas droite 	// Ligne bas, Exi, dyj

		hesEntries.push_back(Tripletd(nodeBIndex, nodeAIndex, 			- A )); // Haut gauche 	// Ligne haut, Exj,  dxi
		hesEntries.push_back(Tripletd(nodeBIndex, nodeAIndex + 1, 		-B )); 	// Haut droite 	// Ligne haut, Exj, dyi
		hesEntries.push_back(Tripletd(nodeBIndex+1, nodeAIndex,  		-B ));	// Bas gauche 	// Ligne bas, Exj, dxi
		hesEntries.push_back(Tripletd(nodeBIndex+1, nodeAIndex +1, 		- D ));	// Bas droite 	// Ligne bas, Exj, dyi

		hesEntries.push_back(Tripletd(nodeBIndex, nodeBIndex, 			A )); 	// Haut gauche 	// Ligne haut, Exj, dxj
		hesEntries.push_back(Tripletd(nodeBIndex, nodeBIndex + 1, 		 B )); 	// Haut droite 	// Ligne haut, Exj, dyj
		hesEntries.push_back(Tripletd(nodeBIndex+1, nodeBIndex,  		 B ));	// Bas gauche 	// Ligne bas, Exj, dxj
		hesEntries.push_back(Tripletd(nodeBIndex+1, nodeBIndex +1, 		D ));	// Bas droite 	// Ligne bas, Exj, dyj

	}

</code></pre>

<h6 id="result-3">Result</h6>
<div style="text-align:center">
<p align="center">
  <img style="height : 300px;" src="/media/compressed/NewtonDescent.png" />
  <img style="height : 300px;" src="/media/compressed/NewtonDescent.gif" />
</p>
</div>

<p>Here again, we can see that’s the second order converge much faster, to the same result.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>total energy = 117.539
# iterations = 3
min def at   = 2.53686e-11
max def at   = 0.0172078
</code></pre></div></div>

<hr />
<p><a name="FEM"></a></p>

<h3 id="2-fem-simulation">2. FEM Simulation</h3>

<p><a name="Graddescent"></a></p>

<h4 id="21-fem-simulation-with-gradient-descent">2.1. FEM simulation with gradient descent</h4>

<p>If the Spring modelization is easy enough, as previously, we can compute derivative analyticaly. In case of more complex Spring modelization - as Neo-Hookean Springs - we can’t easily analyticaly calculate the derivative, as it is already of degree 2.
<br />
In this case, we might use numerical derivation, or automatic differentiation.
We’re going to see an implementation of the numerical derivation solution, with Finite Element Method.
<br />
Some functions will be implemented :</p>
<ul>
  <li>getEnergy, which returns the Neo-Hookean deformation energy of one Spring.</li>
  <li>addEnergyGradientTo, which write the gradient of this deformation in the given array.</li>
</ul>

<h6 id="explanation-4">Explanation</h6>
<p>We compute the energy from the energy density, by simply multiplicate the energy density by the area where this energy is applied. The expression of the Energy density is the Neo-Hookean one.
<br />
We then compute the Gradient, with finite differences, as the difference of energy, normalized, if points involved in the structure are sligtly moved.</p>

<h6 id="usage-4">Usage</h6>
<pre><code class="language-C++">
	virtual double getEnergy(const VectorXd &amp;x, const VectorXd &amp;X)
	{
		// Ex 2.1
		Vector2d xTMP[3];
		xTMP[0] = getNodePos(0, x);
		xTMP[1] = getNodePos(1, x);
		xTMP[2] = getNodePos(2, x);

		computeDeformationGradient(xTMP, dxdX);
		MatrixXd C = (dxdX.transpose() * dxdX);
		double logdetF = log(dxdX.determinant());

		double Energy = (shearModulus * 0.5 * (C.trace() - 2) - shearModulus * logdetF + bulkModulus * 0.5 * logdetF * logdetF);
		return restShapeArea * Energy;
	}

	virtual void addEnergyGradientTo(const VectorXd &amp;x, const VectorXd &amp;X, VectorXd &amp;grad)
	{
		// Ex 2.1
		for (int j = 0; j &lt; 2; j++)
		{
			for (int i = 0; i &lt; 3; i++)
			{
				modified_x_A = x;
				modified_x_B = x;

				modified_x_A[2 * indexPoint[i] + j] += h;
				modified_x_B[2 * indexPoint[i] + j] -= h;
				double Etmp = (getEnergy(modified_x_A, X) - getEnergy(modified_x_B, X)) / (2 * h);
				grad[2 * indexPoint[i] + j] += Etmp;
			}
		}
</code></pre>

<h6 id="result-4">Result</h6>
<div style="text-align:center">
<p align="center">
  <img style="height : 300px;" src="/media/compressed/FEM_GradientDescent.png" />
</p>
</div>

<p>We get a solution, with a high number of iterations.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>total energy = 115.291
# iterations = 6609
min def at   = 4.72342e-08
max def at   = 0.0114811
</code></pre></div></div>

<hr />
<p><a name="Newdescent"></a></p>

<h4 id="22-fem-simulation-with-newtons-method">2.2. FEM simulation with Newton’s method</h4>

<p>Here again, we can extend this derivation to the second order. 
We will need the function addEnergyHessianTo which will add the values of second order derivative to the provided matrix.</p>

<h6 id="explanation-5">Explanation</h6>
<p>We construct the Hessian with finite difference, as the variation of gradients, if we slighlty move 2 points of the initial structure.
As there is a lot (6<em>6) of coefficients to compute, we use iterative structures.
<br />
The positions of each coefficient depends on the 2 points involved (that gives the X position and Y position of the 4</em>4 “block”) and if we are considering X or Y coordinates (which give the position into that block, dxdx in upper left, dydy in bottom right).</p>

<h6 id="usage-5">Usage</h6>
<pre><code class="language-C++">virtual void addEnergyHessianTo(const VectorXd &amp;x, const VectorXd &amp;X, std::vector&lt;Tripletd&gt; &amp;hesEntries)
{
	// Ex 2.2

	//Liste of necessary energies
	for (int i = 0; i &lt; 3; i++)
	{
		for (int j = 0; j &lt; 3; j++)
		{
			//We get the indices of two nodes
			int nodeAIndex = getNodeIndex(i);
			int nodeBIndex = getNodeIndex(j);

			//For the corner of this hessian bloc : xx, xy, yx, yy
			for (int x_val = 0; x_val &lt; 2; x_val++) //Refers to the verical position in the actual 4-sized-square in the Hessian matrix
			{
				for (int y_val = 0; y_val &lt; 2; y_val++) //Refers to the horizontal position in the actual 4-sized-square in the Hessian matrix
				{
					//Set the intiales values of the
					modified_x_A_p_B_p = x;
					modified_x_A_p_B_m = x;
					modified_x_A_m_B_p = x;
					modified_x_A_m_B_m = x;

					//Modify positions
					modified_x_A_p_B_p[2 * nodeAIndex + x_val] += h; //Ax or Ay
					modified_x_A_p_B_p[2 * nodeBIndex + y_val] += h; //Bx or By

					modified_x_A_p_B_m[2 * nodeAIndex + x_val] += h;
					modified_x_A_p_B_m[2 * nodeBIndex + y_val] -= h;

					modified_x_A_m_B_p[2 * nodeAIndex + x_val] -= h;
					modified_x_A_m_B_p[2 * nodeBIndex + y_val] += h;

					modified_x_A_m_B_m[2 * nodeAIndex + x_val] -= h;
					modified_x_A_m_B_m[2 * nodeBIndex + y_val] -= h;

					//Energy calculations
					Energy_A_p_B_p = getEnergy(modified_x_A_p_B_p, X);
					Energy_A_p_B_m = getEnergy(modified_x_A_p_B_m, X);
					Energy_A_m_B_p = getEnergy(modified_x_A_m_B_p, X);
					Energy_A_m_B_m = getEnergy(modified_x_A_m_B_m, X);

					//We compute the Hessian values (Gradients inside)
					double Hess_A_B_x_y = (((Energy_A_p_B_p - Energy_A_p_B_m) / (2 * h)) - ((Energy_A_m_B_p - Energy_A_m_B_m) / (2 * h))) / (2 * h);

					//We add the value in the hessian
					hesEntries.push_back(Tripletd(2 * nodeAIndex + x_val, 2 * nodeBIndex + y_val, Hess_A_B_x_y));
				}
			}

		}
	}

</code></pre>

<h6 id="result-5">Result</h6>
<div style="text-align:center">
<p align="center">
  <img style="height : 300px;" src="/media/compressed/FEM_Newton.png" />
</p>
</div>

<p>Here again, we see a similar solution found (even slighlty better) with a much lower number of iterations.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>total energy = 114.438
# iterations = 6
min def at   = 6.79233e-08
max def at   = 0.0321732
</code></pre></div></div>

<p>For more information, see : 
<a href="https://github.com/VincentFalc/ShapeModeling_5_ConstraintSimulation">-&gt; Repository</a></p>

<p>Note that the code is not optimized by thoughtful laziness: this code is not made to be reused as is in other applications, and if this is the case, the code will be reviewed and optimized. Thanks for your understanding.</p>

                        </div>
                        
                        <div class="catsandtags">
                            
                            <span class="category">
                                <span class="name">categories:</span>
                                Shape Modeling
                            </span>
                            
                            
                                &bull;
                            
                            
                            <span class="tags">
                                <span class="name">tags:</span>
                                
                                    <a href="/tag/Shape Modeling">Shape Modeling</a>
                                
                                    <a href="/tag/IGL">IGL</a>
                                
                                    <a href="/tag/Eigen">Eigen</a>
                                
                                    <a href="/tag/Simulation">Simulation</a>
                                
                                    <a href="/tag/Forces">Forces</a>
                                
                            </span>
                            
                        </div>
                        
                    </article>
                    <div class="post-nav">
                        
                        <a class="btn prev" href="/ShapeModeling-Assi4/"><i class="fa fa-angle-left"></i><span class="short"> prev</span><span class="long">ious post</span></a>
                        
                        
                        <a class="btn next" href="/ShapeModeling-Assi6/"><span class="short">next </span><span class="long">post </span><i class="fa fa-angle-right"></i></a>
                        
                    </div>
                </div>
            </div>
        </div>
        <footer>
    <div class="content">
        <span>Vincent F. powered by &copy; gridster</span>
        <span class="backtotop">Back to top</span>
    </div>
</footer>
<script src="/js/build/global.min.js"></script>
<!-- analytics -->
<script>

  ga('create', 'UA-50358022-5', 'auto');
  ga('send', 'pageview');

</script>
        
    </body>
</html>
